// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package onegame.modello;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;

import onegame.modello.Mossa.TipoMossa;
import onegame.modello.carte.*;
import onegame.modello.carte.CartaSpeciale.TipoSpeciale;
import onegame.modello.giocatori.Giocatore;

/************************************************************/

/**
 * classe centrale dove avviene il gioco
 * 
 * attributi importanti: 
 * lista dei giocatori riferimento al mazzo e alla pilascarti 
 * riferimento ad un navigatore--> gestione semplice della ciclazione dei giocatori 
 * riferimento alla carta corrente sul banco 
 * campi booleani per indicare direzione (true=orario) e se l'effetto della carta corrente è stato attivato (utile per salvataggio)
 * 
 * metodi importanti: 
 * eseguiPrePartita--> fornisce N carte a ciascun giocatore dal mazzo, mette giù la prima carta sul banco 
 * eseguiUnTurno--> esegue un ciclo di gioco (la turnazione adesso viene gestita dal controllore) 
 * vediProssimoGiocatore()--> restituisce prossimo giocatore dopo quello corrente, senza tuttavia cambiarlo (giro orario o antiorario gestito) 
 * prossimoGiocatore()--> come vediProssimoGiocatore, ma viene cambiato il giocatore corrente con il prossimo 
 * applicaEffettoCarta()--> prende la carta corrente e vi applica l'effetto --> effettoAttivato va messo a true 
 * applicaMossa()--> gestisce l'input del giocatore e prova ad applicare la sua mossa alla partita (mossa può essere rimandata al controllore in alcuni casi)
 * verificaFinePartita()-->invocato alla fine di ogni giocata da parte di un giocatore e controlla se non ha più carte (=vince) 
 * pescaCarta()-->fornisce INTERFACCIA per giocatore (pescare carta da mazzo e metterla nella sua mano) 
 * testaGiocaCarta()--> fornisce INTERFACCIA per giocatore (controllare se la carta che sta per giocare il giocatore è valida)
 * giocaCarta()--> fornisce INTERFACCIA per giocatore (mettere carta sul banco--> controlli fatti in giocatore, per ora)
 * 
 */
public class Partita implements PartitaIF {
	private final static int NUMERO_CARTE_INIZIALI = 7;

	private ArrayList<Giocatore> giocatori;
	private Mazzo mazzo;
	private PilaScarti pilaScarti;
	private Navigatore<Giocatore> navigatore;
	private Carta cartaCorrente;
	private boolean direzione;
	private boolean effettoAttivato;
	@JsonIgnore
	private Giocatore vincitore;

	//SEZIONE costruttori
	//costruttore vuoto per Jackson
	public Partita() {}
	
	public Partita(List<Giocatore> giocatori) {
		this.giocatori = new ArrayList<>();
		for (Giocatore g : giocatori) {
			this.giocatori.add(g);
		}
		setPartitaGiocatori();
		this.mazzo = new Mazzo();
		this.mazzo.inizializzaNuovoMazzo();
		this.pilaScarti = new PilaScarti();
		this.navigatore = new Navigatore<>(giocatori);
		this.cartaCorrente = null;
		this.direzione = true;
		this.effettoAttivato = true;
		mazzo.setPila(pilaScarti);
	}
	//------------------------------
	
	//SEZIONE getters & setters
	//metodo che setta la partita di ogni giocatore (utile per quando si deserializza)
	public void setPartitaGiocatori() {
		for(Giocatore g:giocatori)
			g.setPartita(this);
	}
	
	public Carta getCartaCorrente() {
		return cartaCorrente;
	}

	private void setCartaCorrente(Carta cartaCorrente) {
		this.cartaCorrente = cartaCorrente;
	}
	
	public Mazzo getMazzo() {
		return this.mazzo;
	}
	
	public void setMazzo(Mazzo mazzo) {
		this.mazzo = mazzo;
	}
	
	public PilaScarti getPilaScarti() {
		return pilaScarti;
	}

	public void setPilaScarti(PilaScarti pilaScarti) {
		this.pilaScarti = pilaScarti;
	}
	
	//metodo che restituisce il giocatore corrente (utile per gui)
	@JsonIgnore
	public Giocatore getGiocatoreCorrente() {
		return navigatore.corrente();
	}
	
	//metodo che restituisce il vincitore (utile per gui)
	@JsonIgnore
	public Giocatore getVincitore() {
		return this.vincitore;
	}
	

	public ArrayList<Giocatore> getGiocatori() {
		return giocatori;
	}

	//in teoria servirebbe a Jackson per deserializzare, però con le collezioni si può omettere
	//	public void setGiocatori(ArrayList<Giocatore> giocatori) {
	//		this.giocatori = giocatori;
	//	}
	

	public Navigatore<Giocatore> getNavigatore() {
		return navigatore;
	}

	public void setNavigatore(Navigatore<Giocatore> navigatore) {
		this.navigatore = navigatore;
	}

	public boolean isDirezione() {
		return direzione;
	}

	public void setDirezione(boolean direzione) {
		this.direzione = direzione;
	}

	public boolean isEffettoAttivato() {
		return effettoAttivato;
	}

	public void setEffettoAttivato(boolean effettoAttivato) {
		this.effettoAttivato = effettoAttivato;
	}

	//------------------------------

	//SEZIONE funzioni specifiche partita
	//metodo che distribuisce le carte ad inizio partita e setta la carta iniziale
	public void eseguiPrePartita() {
		for (Giocatore g : giocatori) {
			g.getMano().aggiungiCarta(mazzo.pescaN(NUMERO_CARTE_INIZIALI));
			//g.getMano().aggiungiCarta(new CartaSpeciale(Colore.NERO,TipoSpeciale.PIU_QUATTRO));
			//g.getMano().aggiungiCarta(new CartaSpeciale(Colore.NERO,TipoSpeciale.PIU_QUATTRO));
			//g.getMano().aggiungiCarta(new CartaSpeciale(Colore.GIALLO,TipoSpeciale.PIU_DUE));
			//g.getMano().aggiungiCarta(new CartaSpeciale(Colore.GIALLO,TipoSpeciale.PIU_DUE));
			//g.getMano().aggiungiCarta(new CartaNumero(Colore.BLU,2));
			//g.getMano().aggiungiCarta(new CartaNumero(Colore.GIALLO,4));
		}
		Carta first = mazzo.pesca();
		if (first.getColore() == Colore.NERO) {
			first.setColore(Colore.scegliColoreCasuale());
		}
		setCartaCorrente(first);
		//setCartaCorrente(new CartaNumero(Colore.ROSSO,0));
	}

	//metodo che imposta il prossimo turno
	public void eseguiUnTurno() {
		if (verificaFinePartita()) 
			return;
		if (!effettoAttivato) {
			applicaEffettoCarta(cartaCorrente);
			effettoAttivato = true;
		}
		prossimoGiocatore();
	}
	
	//metodo che inverte la turnazione dei giocatori (orario<->antiorario)
	public void cambiaDirezione() {
		direzione=!direzione;
	}
	
	//metodo di validazione (ed eventuale applicazione) di una giocata 
	public Mossa applicaMossa(Giocatore g, Mossa mossa) {
		//caso 1:devo pescare
		if (mossa.getTipoMossa() == TipoMossa.PESCA) 
		{
	        Carta pescata = pescaCarta();
	        g.aggiungiCarta(pescata);
	        //verifico se posso giocare carta pescata--> Mossa modificata in GIOCA_CARTA
	        if (tentaGiocaCarta(pescata)) 
	        {
	        	mossa.setCartaScelta(pescata);
	        	mossa.setTipoMossa(TipoMossa.GIOCA_CARTA);
	            return mossa;
	        }
	        //altrimenti restituisco null--> Mossa CONCLUSA
	        else 
	        {
	            return null;
	        }
	    } 
		//caso 2:devo giocare carta 
		else if (mossa.getTipoMossa() == TipoMossa.GIOCA_CARTA 
				|| mossa.getTipoMossa()==TipoMossa.SCEGLI_COLORE) 
		{
			//verifico se posso giocare carta
	        if(tentaGiocaCarta(mossa.getCartaScelta())||(mossa.getTipoMossa()==TipoMossa.SCEGLI_COLORE)) 
	        {
	        	//verifico se la carta che gioco è NERA--> da cambiare il colore
	        	if(mossa.getCartaScelta().getColore()==Colore.NERO) {
	        		return mossa;
	        	}
	        	//la carta non è (più) da cambiare di colore--> Mossa CONCLUSA
	        	else 
	        	{
	        		g.rimuoveCarta(mossa.getCartaScelta());
					giocaCarta(mossa.getCartaScelta());
	        		return mossa;
	        	}
	        }
	        //altrimenti restituisco null--> carta NON giocabile
	        else 
	        	return null;
	    }
		//caso 3:nessun tipo specificato nella Mossa--
		else
			return null;
	}
	
	//metodo che serve ad applicare l'effetto delle carte speciali
	private void applicaEffettoCarta(Carta c) {
		c.applicaEffetto(this);
	}

	//metodo che restituisce il prossimo giocatore senza modificare il giocatore corrente (utile per gui)
	public Giocatore vediProssimoGiocatore() {
		//direzione=true--> orario, direzione=false--> antiorario
		return direzione ? navigatore.vediProssimo() : navigatore.vediPrecedente();
	}

	//metodo che modifica il prossimo giocatore
	public void prossimoGiocatore() {
		navigatore.setCorrente(vediProssimoGiocatore());
	}
	
	//metodo che controlla se la partita è finita (in quel caso imposta il giocatore vincitore)
	public boolean verificaFinePartita() {
		for (Giocatore g : giocatori) {
			if (g.getMano().getNumCarte() == 0) {
				vincitore=g;
				return true;
			}
		}
		return false;
	}
	//------------------------------
	
	//SEZIONE interfacce per giocatore
	//metodo che restituisce la carta in cima al mazzo
	@Override
	public Carta pescaCarta() {
		return mazzo.pesca();
		//return new CartaSpeciale(Colore.NERO,TipoSpeciale.JOLLY);
	}

	//metodo che controlla se è una carta giocata è compatibile con la carta corrente
	@Override
	public boolean tentaGiocaCarta(Carta tentativo) {
		return tentativo.giocabileSu(cartaCorrente);
	}

	//metodo che imposta la nuova carta corrente, manda la vecchia carta corrente nella pila scarti ed setta a false effettoAttivato
	@Override
	public void giocaCarta(Carta c) {
		if (cartaCorrente != null && cartaCorrente != c) { 
			if(cartaCorrente instanceof CartaSpeciale && (((CartaSpeciale)cartaCorrente).getTipo()==TipoSpeciale.JOLLY
						||((CartaSpeciale)cartaCorrente).getTipo()==TipoSpeciale.PIU_QUATTRO))
					cartaCorrente.setColore(Colore.NERO);
			
	        pilaScarti.mettiCarta(cartaCorrente);
	    }
		setCartaCorrente(c);
		effettoAttivato = false;
	}	
	//------------------------------
}
