// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package modello;

import java.util.ArrayList;
import java.util.Scanner;

import modello.Mossa.TipoMossa;
import modello.carte.*;
import modello.giocatori.Giocatore;
import vista.TemporaryView;

/************************************************************/

/**
 * classe centrale dove avviene il gioco
 * 
 * attributi importanti: 
 * lista dei giocatori riferimento al mazzo e alla pilascarti 
 * riferimento ad un navigatore--> gestione semplice della ciclazione dei giocatori 
 * riferimento alla carta corrente sul banco 
 * campi booleani per indicare direzione (true=orario) e se l'effetto della carta corrente è stato attivato (utile per salvataggio)
 * 
 * metodi importanti: 
 * eseguiPrePartita--> fornisce N carte a ciascun giocatore dal mazzo, mette giù la prima carta sul banco 
 * eseguiUnTurno--> esegue un ciclo di gioco (la turnazione adesso viene gestita dal controllore) 
 * vediProssimoGiocatore()--> restituisce prossimo giocatore dopo quello corrente, senza tuttavia cambiarlo (giro orario o antiorario gestito) 
 * prossimoGiocatore()--> come vediProssimoGiocatore, ma viene cambiato il giocatore corrente con il prossimo 
 * applicaEffettoCarta()--> prende la carta corrente e vi applica l'effetto --> effettoAttivato va messo a true 
 * verificaFinePartita()-->invocato alla fine di ogni giocata da parte di un giocatore e controlla se non ha più carte (=vince) 
 * terminaPartita()--> se restituisce true
 * verificaFinePartita viene invocato questo metodo che dichiara in vincitore
 * pescaCarta()-->fornisce INTERFACCIA per giocatore (pescare carta da mazzo e metterla nella sua mano) 
 * testaGiocaCarta()--> fornisce INTERFACCIA per giocatore (controllare se la carta che sta per giocare il giocatore è valida)
 * giocaCarta()--> fornisce INTERFACCIA per giocatore (mettere carta sul banco--> controlli fatti in giocatore, per ora)
 * 
 */
public class Partita implements PartitaIF {
	private ArrayList<Giocatore> giocatori;
	private Mazzo mazzo;
	private PilaScarti pilaScarti;
	private Navigatore<Giocatore> navigatore;
	private Carta cartaCorrente;
	private boolean direzione;
	private boolean effettoAttivato;

	public Partita(ArrayList<Giocatore> giocatori) {
		this.giocatori = giocatori;
		this.mazzo = new Mazzo();
		this.pilaScarti = new PilaScarti();
		this.navigatore = new Navigatore<>(giocatori);
		this.cartaCorrente = null;
		this.direzione = true;
		this.effettoAttivato = true;
		mazzo.setPila(pilaScarti);
	}

	public void eseguiPrePartita() {
		for (Giocatore g : giocatori) {
			//g.getMano().aggiungiCarta(mazzo.pescaN(7));
			g.getMano().aggiungiCarta(new CartaSpeciale(Colore.NERO,TipoSpeciale.PIU_QUATTRO));
			g.getMano().aggiungiCarta(new CartaSpeciale(Colore.NERO,TipoSpeciale.PIU_QUATTRO));
		}
		Carta first = mazzo.pesca();
		if (first.getColore() == Colore.NERO) {
			first.setColore(Colore.scegliColoreCasuale());
		}
		setCartaCorrente(first);
	}

	public void eseguiUnTurno() {
		if (verificaFinePartita()) 
			return;
		if (!effettoAttivato) {
			applicaEffettoCarta(cartaCorrente);
			effettoAttivato = true;
		}
		prossimoGiocatore();
	}

	public Carta getCartaCorrente() {
		return cartaCorrente;
	}

	private void setCartaCorrente(Carta cartaCorrente) {
		this.cartaCorrente = cartaCorrente;
	}

	public Giocatore getGiocatoreCorrente() {
		return navigatore.corrente();
	}

	private Giocatore vediProssimoGiocatore() {
		//direzione=true--> orario, direzione=false--> antiorario
		return direzione ? navigatore.vediProssimo() : navigatore.vediPrecedente();
	}

	private void prossimoGiocatore() {
		navigatore.setCorrente(vediProssimoGiocatore());
	}

	private void applicaEffettoCarta(Carta c) {
		if (c instanceof CartaSpeciale) {
			switch (((CartaSpeciale) c).getTipo()) {
			case PIU_DUE:
				prossimoGiocatore();
				getGiocatoreCorrente().getMano().aggiungiCarta((mazzo.pescaN(2)));
				break;
			case PIU_QUATTRO:
				prossimoGiocatore();
				getGiocatoreCorrente().getMano().aggiungiCarta((mazzo.pescaN(4)));
				break;
			case BLOCCA:
				prossimoGiocatore();
				break;
			case INVERTI:
				direzione = (!direzione);
				break;
			default:
				prossimoGiocatore();
				break;
			}
		}
	}
	
	/*
	public Mossa applicaMossa(Giocatore g, Mossa mossa) {
		if (mossa.getTipoMossa() == TipoMossa.PESCA) {
	        Carta pescata = pescaCarta();
	        g.aggiungiCarta(pescata);
	        if (tentaGiocaCarta(pescata)) {
	            return new Mossa(TipoMossa.GIOCA_CARTA,pescata);
	        } else {
	            return null;
	        }
	    } else if (mossa.getTipoMossa() == TipoMossa.GIOCA_CARTA || mossa.getTipoMossa()==TipoMossa.SCEGLI_COLORE) {
	        if(tentaGiocaCarta(mossa.getCartaMossa())) {
	        	if(mossa.getCartaMossa().getColore()==Colore.NERO)
	        		return new Mossa(TipoMossa.SCEGLI_COLORE,mossa.getCartaMossa());
	        	else {
	        		g.rimuoveCarta(mossa.getCartaMossa());
					giocaCarta(mossa.getCartaMossa());
	        		return mossa;
	        	}
	        }
	        else 
	        	return null;
	    }
		return null;
	}
	*/

	public boolean verificaFinePartita() {
		for (Giocatore g : giocatori) {
			if (g.getMano().getNumCarte() == 0) {
				return true;
			}
		}
		return false;
	}

	@Override
	public Carta pescaCarta() {
		return mazzo.pesca();
	}

	@Override
	public boolean tentaGiocaCarta(Carta tentativo) {
		return tentativo.giocabileSu(cartaCorrente);
	}

	@Override
	public void giocaCarta(Carta c) {
		pilaScarti.mettiCarta(cartaCorrente);
		setCartaCorrente(c);
		effettoAttivato = false;
	}
}
