// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package modello;

import java.util.ArrayList;
import java.util.Scanner;

import modello.carte.*;
import modello.giocatori.Giocatore;

/************************************************************/

/**
 * classe centrale dove avviene il gioco
 * 
 * attributi importanti:
 * lista dei giocatori
 * riferimento al mazzo e alla pilascarti
 * riferimento ad un navigatore--> gestione semplice della ciclazione dei giocatori
 * riferimento al giocatore corrente--> coincide con navigatore.current()
 * riferimento alla carta corrente sul banco
 * campi booleani per indicare direzione (true=orario) e se l'effetto della carta corrente è stato attivato (utile per salvataggio)
 * scanner--> TEMPORANEO
 * 
 * metodi importanti:
 * distribuisciCarte()--> fornisce N carte a ciascun giocatore dal mazzo
 * vediProssimoGiocatore()--> restituisce prossimo giocatore dopo quello corrente, senza tuttavia cambiarlo (giro orario o antiorario gestito)
 * prossimoGiocatore()--> come vediProssimoGiocatore, ma viene cambiato il giocatore corrente con il prossimo
 * applicaEffettoCarta()--> prende la carta corrente e vi applica l'effetto --> effettoAttivato va messo a true
 * avvia()--> gioco vero e proprio (while true finchè non vince qualcuno)
 * verificaFinePartita()--> invocato alla fine di ogni giocata da parte di un giocatore e controlla se non ha più carte (=vince)
 * terminaPartita()--> se restituisce true verificaFinePartita viene invocato questo metodo che dichiara in vincitore
 * pescaCarta()-->fornisce INTERFACCIA per giocatore (pescare carta da mazzo e metterla nella sua mano)
 * giocaCarta()--> fornisce INTERFACCIA per giocatore (mettere carta sul banco--> controlli fatti in giocatore, per ora)
 * 
 */
public class Partita implements PartitaIF {
	private ArrayList<Giocatore> giocatori;
	private Mazzo mazzo;
	private PilaScarti pilaScarti;
	private Navigatore<Giocatore> navigatore;
	private Giocatore turnoCorrente;
	private Carta cartaCorrente;
	private boolean direzione;
	private boolean effettoAttivato;
	private Scanner sc;

	public Partita(ArrayList<Giocatore> giocatori) {
		this.giocatori = giocatori;
		this.mazzo = new Mazzo();
		this.pilaScarti = new PilaScarti();
		this.navigatore=new Navigatore<>(giocatori);
		this.turnoCorrente = navigatore.current();
		this.cartaCorrente = null;
		this.direzione = true;
		this.effettoAttivato=true;
		sc=new Scanner(System.in);
		mazzo.setPila(pilaScarti);
	}

	private void distribuisciCarte() {
		for (Giocatore g : giocatori) {
			g.setInterfacciaPartita(this);
			g.getMano().aggiungiCarta(new CartaSpeciale(Colore.BLU,TipoSpeciale.INVERTI));
			g.getMano().aggiungiCarta(new CartaSpeciale(Colore.NERO,TipoSpeciale.JOLLY));
		}
	}
	
	public Carta getCartaCorrente() {
		return cartaCorrente;
	}

	public void setCartaCorrente(Carta cartaCorrente) {
		this.cartaCorrente = cartaCorrente;
	}
	
	public Giocatore getGiocatoreCorrente() {
		return turnoCorrente;
	}
	
	public Giocatore vediProssimoGiocatore() {
		//default--> senso orario
		if(direzione) {
			return navigatore.peekNext();
		}
		//senso anti-orario
		else {
			return navigatore.peekBack();
		}
	}
	
	public void prossimoGiocatore() {
		navigatore.setCurrent(vediProssimoGiocatore());
		turnoCorrente=navigatore.current();
	}

	public void applicaEffettoCarta(Carta c) {
		if (c instanceof CartaSpeciale) {
			switch (((CartaSpeciale) c).getTipo()) {
			case PIU_DUE:
				prossimoGiocatore();
				turnoCorrente.getMano().aggiungiCarta((mazzo.pescaN(2)));
				break;
			case PIU_QUATTRO:
				prossimoGiocatore();
				turnoCorrente.getMano().aggiungiCarta((mazzo.pescaN(4)));
				break;
			case BLOCCA:
				prossimoGiocatore();
				break;
			case INVERTI:
				direzione=(!direzione);
				break;
			default:
				prossimoGiocatore();
				break;
			}
		}
	}
	
	public void avvia() {
		distribuisciCarte();
		Carta first=mazzo.pesca();
		if(first.getColore()==Colore.NERO) {
			first.setColore(Colore.scegliColoreCasuale());
		}
		setCartaCorrente(first);
		while (true) {
			getGiocatoreCorrente().giocaTurno(getCartaCorrente(), sc);
			if (verificaFinePartita()) {
				terminaPartita(getGiocatoreCorrente());
				break;
			} else {
				if(!effettoAttivato) {
					applicaEffettoCarta(cartaCorrente);
					effettoAttivato=true;
				}
				prossimoGiocatore();
			}
		}
	}

	public boolean verificaFinePartita() {
		for (Giocatore g : giocatori) {
			if (g.getMano().getNumCarte() == 0) {
				return true;
			}
		}
		return false;
	}

	public void terminaPartita(Giocatore vincitore) {
		System.out.println("Ha vinto " + vincitore + "!");
	}

	@Override
	public Carta pescaCarta() {
		return mazzo.pesca();
	}

	@Override
	public void giocaCarta(Carta c) {
		pilaScarti.mettiCarta(cartaCorrente);
		turnoCorrente.getMano().getCarte().remove(c);
		setCartaCorrente(c);
		effettoAttivato=false;
		System.out.println(pilaScarti.getCarte().size());
	}
}
